<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phrase Practice - Czech Learning</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .header p {
            color: #666;
            font-size: 16px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        .audio-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e1e5e9;
        }
        .btn-secondary:hover {
            background: #e9ecef;
        }
        .btn-record {
            background: #dc3545;
            color: white;
        }
        .btn-record.recording {
            background: #28a745;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .results {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        .score-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .score-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .score-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        .words-analysis {
            margin-top: 20px;
        }
        .word-item {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }
        .word-correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .word-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef } = React;

        function PronunciationAssessment() {
            const referenceText = 'jmenuji se';
            const language = 'cs-CZ';
            const [isRecording, setIsRecording] = useState(false);
            const [audioBlob, setAudioBlob] = useState(null);
            const [results, setResults] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);

            const languages = [
                { code: 'cs-CZ', name: '–ß–µ—à—Å–∫–∏–π' },
                { code: 'en-US', name: '–ê–Ω–≥–ª–∏–π—Å–∫–∏–π (–°–®–ê)' },
                { code: 'de-DE', name: '–ù–µ–º–µ—Ü–∫–∏–π' },
                { code: 'fr-FR', name: '–§—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π' },
                { code: 'es-ES', name: '–ò—Å–ø–∞–Ω—Å–∫–∏–π' },
                { code: 'it-IT', name: '–ò—Ç–∞–ª—å—è–Ω—Å–∫–∏–π' },
                { code: 'pt-BR', name: '–ü–æ—Ä—Ç—É–≥–∞–ª—å—Å–∫–∏–π (–ë—Ä–∞–∑–∏–ª–∏—è)' },
                { code: 'ru-RU', name: '–†—É—Å—Å–∫–∏–π' },
                { code: 'zh-CN', name: '–ö–∏—Ç–∞–π—Å–∫–∏–π' },
                { code: 'ja-JP', name: '–Ø–ø–æ–Ω—Å–∫–∏–π' },
                { code: 'ko-KR', name: '–ö–æ—Ä–µ–π—Å–∫–∏–π' }
            ];

            const checkMediaSupport = () => {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    return {
                        supported: false,
                        reason: 'MediaDevices API not supported. Please use HTTPS or a modern browser.'
                    };
                }
                
                if (!window.MediaRecorder) {
                    return {
                        supported: false,
                        reason: 'MediaRecorder API not supported in this browser.'
                    };
                }
                
                return { supported: true };
            };

            const startRecording = async () => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É API
                const mediaSupport = checkMediaSupport();
                if (!mediaSupport.supported) {
                    setError(mediaSupport.reason);
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000
                        } 
                    });
                    
                    mediaRecorderRef.current = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    audioChunksRef.current = [];

                    mediaRecorderRef.current.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunksRef.current.push(event.data);
                        }
                    };

                    mediaRecorderRef.current.onstop = () => {
                        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
                        setAudioBlob(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorderRef.current.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        setError('Recording error: ' + event.error.message);
                    };

                    mediaRecorderRef.current.start(1000); // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —á–∞–Ω–∫–∞–º–∏ –ø–æ 1 —Å–µ–∫—É–Ω–¥–µ
                    setIsRecording(true);
                    setError('');
                } catch (err) {
                    console.error('–û—à–∏–±–∫–∞ startRecording:', err);
                    console.error('Microphone error details:', {
                        name: err.name,
                        message: err.message,
                        stack: err.stack
                    });
                    
                    let errorMessage = 'Microphone access error: ';
                    if (err.name === 'NotAllowedError') {
                        errorMessage += 'Permission denied. Please allow microphone access.';
                    } else if (err.name === 'NotFoundError') {
                        errorMessage += 'No microphone found. Please connect a microphone.';
                    } else if (err.name === 'NotSupportedError') {
                        errorMessage += 'Audio recording not supported in this browser.';
                    } else if (err.name === 'SecurityError') {
                        errorMessage += 'Security error. Please use HTTPS.';
                    } else {
                        errorMessage += err.message;
                    }
                    
                    setError(errorMessage);
                }
            };

            const stopRecording = () => {
                if (mediaRecorderRef.current && isRecording) {
                    mediaRecorderRef.current.stop();
                    setIsRecording(false);
                }
            };

            const convertToWavBase64 = async (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async () => {
                        try {
                            const arrayBuffer = reader.result;
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                            
                            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ WAV —Ñ–æ—Ä–º–∞—Ç
                            const wavBuffer = audioBufferToWav(audioBuffer);
                            const base64 = arrayBufferToBase64(wavBuffer);
                            resolve(base64);
                        } catch (error) {
                            console.error('–û—à–∏–±–∫–∞ convertToWavBase64:', error);
                            console.error('Error details:', {
                                name: error.name,
                                message: error.message,
                                stack: error.stack
                            });
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(blob);
                });
            };

            const audioBufferToWav = (buffer) => {
                const length = buffer.length;
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const bytesPerSample = 2;
                const blockAlign = numberOfChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = length * blockAlign;
                const bufferSize = 44 + dataSize;
                
                const arrayBuffer = new ArrayBuffer(bufferSize);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, bufferSize - 8, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, dataSize, true);
                
                // Convert audio data
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return arrayBuffer;
            };

            const arrayBufferToBase64 = (buffer) => {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            };

            const analyzePronounciation = async () => {
                if (!audioBlob) {
                    setError('Please record your pronunciation of "Jmenuji se"');
                    return;
                }

                setLoading(true);
                setError('');
                setResults(null);

                try {
                    const audioBase64 = await convertToWavBase64(audioBlob);
                    
                    const requestData = {
                        audio_data: audioBase64,
                        reference_text: referenceText,
                        language: language
                    };
                    
                    console.log('–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ:', {
                        reference_text: requestData.reference_text,
                        language: requestData.language,
                        audio_size: requestData.audio_data.length
                    });
                    
                    const response = await fetch('http://85.198.82.170:12500/api/v1/azure/pronunciation-assessment', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestData)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞');
                    }

                    const data = await response.json();
                    setResults(data);
                } catch (err) {
                    console.error('–û—à–∏–±–∫–∞ –≤ analyzePronounciation:', err);
                    console.error('Stack trace:', err.stack);
                    
                    let errorMessage = 'Analysis error: ';
                    if (err.name === 'TypeError') {
                        errorMessage += 'Network or data format error - ' + err.message;
                    } else if (err.message.includes('fetch')) {
                        errorMessage += 'Network connection error - ' + err.message;
                    } else if (err.message.includes('JSON')) {
                        errorMessage += 'Server response format error - ' + err.message;
                    } else if (err.message.includes('decodeAudioData')) {
                        errorMessage += 'Audio format conversion error - ' + err.message;
                    } else {
                        errorMessage += err.message;
                    }
                    
                    setError(errorMessage);
                } finally {
                    setLoading(false);
                }
            };

            const getScoreColor = (score) => {
                if (score >= 80) return '#28a745';
                if (score >= 60) return '#ffc107';
                return '#dc3545';
            };

            return (
                <div className="container">
                    <div className="header">
                        <h1>üìö Phrase Practice</h1>
                        <p>Learn Czech pronunciation by watching the video and repeating the phrase</p>
                    </div>

                    <div className="video-section" style={{ marginBottom: '30px', textAlign: 'center' }}>
                        <h3 style={{ marginBottom: '15px', color: '#333' }}>üìπ Watch and Listen</h3>
                        <video 
                            controls 
                            style={{ 
                                width: '100%', 
                                maxWidth: '500px', 
                                borderRadius: '10px',
                                boxShadow: '0 5px 15px rgba(0,0,0,0.2)'
                            }}
                        >
                            <source src="media/example.mp4" type="video/mp4" />
                            Your browser does not support the video tag.
                        </video>
                        <div style={{ 
                            marginTop: '15px', 
                            fontSize: '24px', 
                            fontWeight: 'bold', 
                            color: '#667eea',
                            padding: '10px',
                            background: '#f8f9fa',
                            borderRadius: '8px',
                            border: '2px solid #e1e5e9'
                        }}>
                            "jmenuji se"
                        </div>
                        <p style={{ color: '#666', fontSize: '14px', marginTop: '10px' }}>
                            Practice saying this Czech phrase meaning "My name is"
                        </p>
                    </div>

                    <div className="form-group">
                        <label>Record Your Pronunciation:</label>
                        <div className="audio-controls">
                            <button
                                className={`btn-record ${isRecording ? 'recording' : ''}`}
                                onClick={isRecording ? stopRecording : startRecording}
                            >
                                {isRecording ? '‚èπÔ∏è Stop Recording' : 'üé§ Start Recording'}
                            </button>
                            {audioBlob && (
                                <span style={{ color: '#28a745', fontSize: '14px' }}>
                                    ‚úÖ Audio Recorded
                                </span>
                            )}
                        </div>
                        <div style={{ fontSize: '12px', color: '#666', marginTop: '8px' }}>
                            üìã <strong>Requirements:</strong> HTTPS connection and microphone permission required for audio recording
                        </div>
                    </div>

                    <button
                        className="btn-primary"
                        onClick={analyzePronounciation}
                        disabled={loading || !audioBlob}
                        style={{ width: '100%', marginTop: '20px' }}
                    >
                        {loading ? 'Analyzing...' : 'üîç Check My Pronunciation'}
                    </button>

                    {loading && (
                        <div className="loading">
                            <div className="spinner"></div>
                            <p>Analyzing your pronunciation...</p>
                        </div>
                    )}

                    {error && (
                        <div className="error">
                            <strong>Error:</strong> {error}
                        </div>
                    )}

                    {results && (
                        <div className="results">
                            <h3>üìä Pronunciation Results</h3>
                            
                            <div style={{ marginBottom: '20px' }}>
                                <p><strong>What you said:</strong> "{results.recognized_text}"</p>
                                <p><strong>Target phrase:</strong> "{results.reference_text}"</p>
                            </div>

                            <div className="score-grid">
                                <div className="score-card">
                                    <div className="score-value" style={{ color: getScoreColor(results.scores.pronunciation_score) }}>
                                        {results.scores.pronunciation_score.toFixed(1)}
                                    </div>
                                    <div className="score-label">Overall Score</div>
                                </div>
                                <div className="score-card">
                                    <div className="score-value" style={{ color: getScoreColor(results.scores.accuracy_score) }}>
                                        {results.scores.accuracy_score.toFixed(1)}
                                    </div>
                                    <div className="score-label">Accuracy</div>
                                </div>
                                <div className="score-card">
                                    <div className="score-value" style={{ color: getScoreColor(results.scores.fluency_score) }}>
                                        {results.scores.fluency_score.toFixed(1)}
                                    </div>
                                    <div className="score-label">Fluency</div>
                                </div>
                                <div className="score-card">
                                    <div className="score-value" style={{ color: getScoreColor(results.scores.completeness_score) }}>
                                        {results.scores.completeness_score.toFixed(1)}
                                    </div>
                                    <div className="score-label">Completeness</div>
                                </div>
                            </div>

                            {results.words_analysis && results.words_analysis.length > 0 && (
                                <div className="words-analysis">
                                    <h4>üìù Word Analysis:</h4>
                                    <div>
                                        {results.words_analysis.map((word, index) => (
                                            <div key={index} className="word-analysis-item" style={{ 
                                                display: 'inline-block', 
                                                margin: '8px',
                                                padding: '12px',
                                                borderRadius: '8px',
                                                border: '2px solid',
                                                borderColor: word.error_type === 'None' ? '#28a745' : '#dc3545',
                                                backgroundColor: word.error_type === 'None' ? '#d4edda' : '#f8d7da'
                                            }}>
                                                <div style={{ 
                                                    fontWeight: 'bold', 
                                                    fontSize: '16px',
                                                    color: word.error_type === 'None' ? '#155724' : '#721c24',
                                                    marginBottom: '4px'
                                                }}>
                                                    {word.word}
                                                </div>
                                                <div style={{ 
                                                    fontSize: '12px',
                                                    color: word.error_type === 'None' ? '#155724' : '#721c24'
                                                }}>
                                                    Accuracy: {word.accuracy_score.toFixed(1)}%
                                                </div>
                                                <div style={{ 
                                                    fontSize: '11px',
                                                    fontWeight: 'bold',
                                                    marginTop: '2px',
                                                    color: word.error_type === 'None' ? '#0f5132' : '#58151c'
                                                }}>
                                                    {word.error_type === 'None' ? '‚úÖ Correct' : 
                                                     word.error_type === 'Mispronunciation' ? '‚ùå Mispronounced' :
                                                     word.error_type === 'Omission' ? '‚ö†Ô∏è Omitted' :
                                                     word.error_type === 'Insertion' ? '‚ûï Extra word' :
                                                     `‚ö†Ô∏è ${word.error_type}`}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<PronunciationAssessment />, document.getElementById('root'));
    </script>
</body>
</html>
